---
const { id, colors, width = '60%', float = 'right', height = '300px' } = Astro.props;
---

<canvas id={id} class="inline-shader" data-float={float} data-width={width} data-height={height}></canvas>

<style>
  .inline-shader {
    display: block;
    margin: var(--space-md) 0;
  }

  .inline-shader[data-float="right"] {
    float: right;
    margin-left: var(--space-md);
  }

  .inline-shader[data-float="left"] {
    float: left;
    margin-right: var(--space-md);
  }

  .inline-shader[data-float="center"] {
    margin-left: auto;
    margin-right: auto;
  }
</style>

<script define:vars={{ id, colors, width, height }}>
  const canvas = document.getElementById(id);
  const gl = canvas.getContext('webgl');

  // Set canvas size based on props
  canvas.style.width = width;
  canvas.style.height = height;

  const displayWidth = canvas.offsetWidth;
  const displayHeight = canvas.offsetHeight;

  canvas.width = displayWidth;
  canvas.height = displayHeight;

  gl.viewport(0, 0, canvas.width, canvas.height);

  const vsSource = `
    attribute vec2 position;
    void main() {
      gl_Position = vec4(position, 0.0, 1.0);
    }
  `;

  const fsSource = `
    precision mediump float;
    uniform vec2 resolution;
    uniform float time;
    uniform vec3 color1;
    uniform vec3 color2;
    uniform vec3 color3;

    float random(vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
    }

    void main() {
      vec2 uv = gl_FragCoord.xy / resolution;

      float pattern1 = sin(uv.x * 10.0 + time * 0.5) * cos(uv.y * 8.0 + time * 0.3);
      float pattern2 = sin(uv.x * 6.0 - time * 0.4) * cos(uv.y * 12.0 - time * 0.2);
      float pattern3 = sin(uv.x * 15.0 + uv.y * 10.0 + time * 0.6);

      vec3 color = mix(color1, color2, pattern1 * 0.5 + 0.5);
      color = mix(color, color3, pattern2 * 0.5 + 0.5);
      color += vec3(pattern3 * 0.1);

      float noise = random(uv * 100.0 + time) * 0.15 - 0.075;
      color += vec3(noise);

      gl_FragColor = vec4(color, 1.0);
    }
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  const positions = new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
     1,  1,
  ]);

  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

  const positionLocation = gl.getAttribLocation(program, 'position');
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  const resolutionLocation = gl.getUniformLocation(program, 'resolution');
  const timeLocation = gl.getUniformLocation(program, 'time');
  const color1Location = gl.getUniformLocation(program, 'color1');
  const color2Location = gl.getUniformLocation(program, 'color2');
  const color3Location = gl.getUniformLocation(program, 'color3');

  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
  gl.uniform3f(color1Location, colors[0][0], colors[0][1], colors[0][2]);
  gl.uniform3f(color2Location, colors[1][0], colors[1][1], colors[1][2]);
  gl.uniform3f(color3Location, colors[2][0], colors[2][1], colors[2][2]);

  let startTime = Date.now();
  function render() {
    const time = (Date.now() - startTime) * 0.001;
    gl.uniform1f(timeLocation, time);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
  }

  render();
</script>
